<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>xdrpp: xdrpp/types.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xdrpp
   </div>
   <div id="projectbrief">RFC4506 XDR compiler and message library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_9f9c97483b854a13f7ef61e10e2c0e05.html">xdrpp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">types.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Type definitions for xdrc compiler output.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;array&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;stdexcept&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;<a class="el" href="endian_8h_source.html">xdrpp/endian.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for types.h:</div>
<div class="dyncontent">
<div class="center"><img src="types_8h__incl.png" border="0" usemap="#xdrpp_2types_8h" alt=""/></div>
<map name="xdrpp_2types_8h" id="xdrpp_2types_8h">
<area shape="rect" id="node13" href="endian_8h.html" title="Low&#45;level byteswap and miscellaneous OS compatibility routines. " alt="" coords="221,80,328,107"/>
<area shape="rect" id="node14" href="build__endian_8h.html" title="Endianness of build machine. " alt="" coords="204,155,345,181"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="types_8h__dep__incl.png" border="0" usemap="#xdrpp_2types_8hdep" alt=""/></div>
<map name="xdrpp_2types_8hdep" id="xdrpp_2types_8hdep">
<area shape="rect" id="node2" href="rpc__msg_8hh_source.html" title="xdrpp/rpc_msg.hh" alt="" coords="263,80,390,107"/>
<area shape="rect" id="node14" href="marshal_8h.html" title="Support for marshaling XDR types in the format specified by RFC4506. " alt="" coords="460,80,575,107"/>
<area shape="rect" id="node16" href="printer_8h.html" title="Support for pretty&#45;printing XDR data types. " alt="" coords="599,80,705,107"/>
<area shape="rect" id="node18" href="autocheck_8h_source.html" title="Support for using the autocheck framework with XDR data types. " alt="" coords="782,80,911,107"/>
<area shape="rect" id="node19" href="cereal_8h.html" title="Interface for cereal serealization back ends. " alt="" coords="936,80,1040,107"/>
<area shape="rect" id="node20" href="clear_8h.html" title="Support for clearing an XDR data structure. " alt="" coords="1065,80,1162,107"/>
<area shape="rect" id="node21" href="rpcb__prot_8hh_source.html" title="xdrpp/rpcb_prot.hh" alt="" coords="685,229,816,256"/>
<area shape="rect" id="node3" href="exception_8h.html" title="Exceptions raised by RPC calls. " alt="" coords="119,155,244,181"/>
<area shape="rect" id="node11" href="server_8h.html" title="Classes for implementing RPC servers. " alt="" coords="466,155,571,181"/>
<area shape="rect" id="node12" href="msgsock_8cc_source.html" title="xdrpp/msgsock.cc" alt="" coords="345,229,474,256"/>
<area shape="rect" id="node4" href="arpc_8h.html" title="Asynchronous RPC interface. " alt="" coords="226,304,321,331"/>
<area shape="rect" id="node6" href="srpc_8h.html" title="Simple synchronous RPC functions. " alt="" coords="226,229,321,256"/>
<area shape="rect" id="node9" href="srpc_8cc_source.html" title="xdrpp/srpc.cc" alt="" coords="17,304,119,331"/>
<area shape="rect" id="node10" href="rpc__msg_8cc_source.html" title="xdrpp/rpc_msg.cc" alt="" coords="23,229,150,256"/>
<area shape="rect" id="node5" href="arpc_8cc_source.html" title="xdrpp/arpc.cc" alt="" coords="223,379,324,405"/>
<area shape="rect" id="node7" href="rpcbind_8cc_source.html" title="xdrpp/rpcbind.cc" alt="" coords="439,304,558,331"/>
<area shape="rect" id="node8" href="socket__unix_8cc_source.html" title="xdrpp/socket_unix.cc" alt="" coords="629,304,776,331"/>
<area shape="rect" id="node13" href="server_8cc_source.html" title="xdrpp/server.cc" alt="" coords="549,229,661,256"/>
<area shape="rect" id="node15" href="marshal_8cc_source.html" title="xdrpp/marshal.cc" alt="" coords="319,155,441,181"/>
<area shape="rect" id="node17" href="printer_8cc_source.html" title="xdrpp/printer.cc" alt="" coords="595,155,707,181"/>
</map>
</div>
</div>
<p><a href="types_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__runtime__error.html">xdr::xdr_runtime_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic class of XDR unmarshaling errors.  <a href="structxdr_1_1xdr__runtime__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__overflow.html">xdr::xdr_overflow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to exceed the bounds of a variable-length array or string.  <a href="structxdr_1_1xdr__overflow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__bad__message__size.html">xdr::xdr_bad_message_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message not multiple of 4 bytes, or cannot fully be parsed.  <a href="structxdr_1_1xdr__bad__message__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__bad__discriminant.html">xdr::xdr_bad_discriminant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to set invalid value for a union discriminant.  <a href="structxdr_1_1xdr__bad__discriminant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__should__be__zero.html">xdr::xdr_should_be_zero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Padding bytes that should have contained zero don't.  <a href="structxdr_1_1xdr__should__be__zero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__invariant__failed.html">xdr::xdr_invariant_failed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for use by <code>xdr::xdr_validate</code>.  <a href="structxdr_1_1xdr__invariant__failed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__wrong__union.html">xdr::xdr_wrong_union</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to access wrong field of a union.  <a href="structxdr_1_1xdr__wrong__union.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1archive__adapter.html">xdr::archive_adapter&lt; Archive &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to apply an archive to a field.  <a href="structxdr_1_1archive__adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits.html">xdr::xdr_traits&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata for all marshalable XDR types.  <a href="structxdr_1_1xdr__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits__base.html">xdr::xdr_traits_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <a class="el" href="structxdr_1_1xdr__traits.html" title="Metadata for all marshalable XDR types. ">xdr_traits</a> values for actual XDR types, used as a supertype for most <a class="el" href="structxdr_1_1xdr__traits.html" title="Metadata for all marshalable XDR types. ">xdr::xdr_traits</a> specializations.  <a href="structxdr_1_1xdr__traits__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__integral__base.html">xdr::xdr_integral_base&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default traits for use as supertype of specializations of <code><a class="el" href="structxdr_1_1xdr__traits.html" title="Metadata for all marshalable XDR types. ">xdr_traits</a></code> for integral types.  <a href="structxdr_1_1xdr__integral__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01std_1_1int32__t_01_4.html">xdr::xdr_traits&lt; std::int32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01std_1_1uint32__t_01_4.html">xdr::xdr_traits&lt; std::uint32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01std_1_1int64__t_01_4.html">xdr::xdr_traits&lt; std::int64_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01std_1_1uint64__t_01_4.html">xdr::xdr_traits&lt; std::uint64_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__fp__base.html">xdr::xdr_fp_base&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default traits for use as supertype of specializations of <code><a class="el" href="structxdr_1_1xdr__traits.html" title="Metadata for all marshalable XDR types. ">xdr_traits</a></code> for floating-point types.  <a href="structxdr_1_1xdr__fp__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01float_01_4.html">xdr::xdr_traits&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01double_01_4.html">xdr::xdr_traits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01bool_01_4.html">xdr::xdr_traits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xarray.html">xdr::xarray&lt; T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">XDR arrays are implemented using std::array as a supertype.  <a href="structxdr_1_1xarray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01xarray_3_01_t_00_01_n_01_4_01_4.html">xdr::xdr_traits&lt; xarray&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1opaque__array.html">xdr::opaque_array&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">XDR <code>opaque</code> is represented as std::uint8_t;.  <a href="structxdr_1_1opaque__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01opaque__array_3_01_n_01_4_01_4.html">xdr::xdr_traits&lt; opaque_array&lt; N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xvector.html">xdr::xvector&lt; T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector with a maximum size (returned by <a class="el" href="structxdr_1_1xvector.html#a138117a326165c047497a7fca76b4c74" title="Return the maximum size allowed by the type. ">xvector::max_size()</a>).  <a href="structxdr_1_1xvector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01xvector_3_01_t_00_01_n_01_4_01_4.html">xdr::xdr_traits&lt; xvector&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01xvector_3_01std_1_1uint8__t_00_01_n_01_4_01_4.html">xdr::xdr_traits&lt; xvector&lt; std::uint8_t, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xstring.html">xdr::xstring&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string with a maximum length (returned by <a class="el" href="structxdr_1_1xstring.html#a432cab05af13b6b1d215f2b1a48749b9" title="Return the maximum size allowed by the type. ">xstring::max_size()</a>).  <a href="structxdr_1_1xstring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01xstring_3_01_n_01_4_01_4.html">xdr::xdr_traits&lt; xstring&lt; N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1pointer.html">xdr::pointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional data (represented with pointer notation in XDR source).  <a href="structxdr_1_1pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01pointer_3_01_t_01_4_01_4.html">xdr::xdr_traits&lt; pointer&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1field__ptr.html">xdr::field_ptr&lt; T, F, Ptr &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-level representation of a pointer-to-member value.  <a href="structxdr_1_1field__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__struct__base.html">xdr::xdr_struct_base&lt; Fields &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__struct__base_3_4.html">xdr::xdr_struct_base&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supertype to construct XDR traits of structure objects, used in output of the <code>xdrc</code> compiler.  <a href="structxdr_1_1xdr__struct__base_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__struct__base_3_01_f_p_00_01_rest_8_8_8_01_4.html">xdr::xdr_struct_base&lt; FP, Rest... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1indices.html">xdr::indices&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder type used to contain a parameter pack of tuple indices, so as to unpack a tuple in function call arguments.  <a href="structxdr_1_1indices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01std_1_1tuple_3_01_t_8_8_8_01_4_01_4.html">xdr::xdr_traits&lt; std::tuple&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1field__constructor__t.html">xdr::field_constructor_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1field__destructor__t.html">xdr::field_destructor_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1field__assigner__t.html">xdr::field_assigner_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1field__archiver__t.html">xdr::field_archiver_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1field__size__t.html">xdr::field_size_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacexdr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html">xdr</a></td></tr>
<tr class="memdesc:namespacexdr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most of the xdrpp library is encapsulated in the xdr namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a257dd8b678289e2079895d77bd299dfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a257dd8b678289e2079895d77bd299dfd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ASSIGN_LIKE</b>(method)</td></tr>
<tr class="separator:a257dd8b678289e2079895d77bd299dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa08a12c21ae987530a9aadfdec31e593"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa08a12c21ae987530a9aadfdec31e593"></a>
template&lt;uint32_t N = XDR_MAX_LEN&gt; </td></tr>
<tr class="memitem:aa08a12c21ae987530a9aadfdec31e593"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#aa08a12c21ae987530a9aadfdec31e593">xdr::opaque_vec</a> = xvector&lt; std::uint8_t, N &gt;</td></tr>
<tr class="memdesc:aa08a12c21ae987530a9aadfdec31e593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable-length opaque data is just a vector of std::uint8_t. <br /></td></tr>
<tr class="separator:aa08a12c21ae987530a9aadfdec31e593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c6ab2a25cb7603d964833140dbfcdb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a20c6ab2a25cb7603d964833140dbfcdb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20c6ab2a25cb7603d964833140dbfcdb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a20c6ab2a25cb7603d964833140dbfcdb">xdr::all_indices_of</a> = typename detail::all_indices&lt; std::tuple_size&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value &gt;</td></tr>
<tr class="memdesc:a20c6ab2a25cb7603d964833140dbfcdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing all the indices of a particuar tuple. <br /></td></tr>
<tr class="separator:a20c6ab2a25cb7603d964833140dbfcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8434488dfa0bf61c3ba2714eb1e6ffba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8434488dfa0bf61c3ba2714eb1e6ffba"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a8434488dfa0bf61c3ba2714eb1e6ffba">xdr::xdr_void</a> = std::tuple&lt;&gt;</td></tr>
<tr class="memdesc:a8434488dfa0bf61c3ba2714eb1e6ffba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placehoder type representing void values marshaled as 0 bytes. <br /></td></tr>
<tr class="separator:a8434488dfa0bf61c3ba2714eb1e6ffba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af39078b69403c4180075e8e0a6ed1b8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af39078b69403c4180075e8e0a6ed1b8c"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>xdr::size32</b> (std::size_t s)</td></tr>
<tr class="separator:af39078b69403c4180075e8e0a6ed1b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7c4c84c79a69d0bad433bff349741a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e7c4c84c79a69d0bad433bff349741a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a8e7c4c84c79a69d0bad433bff349741a">xdr::validate</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a8e7c4c84c79a69d0bad433bff349741a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this function template is specialized, it provides a means of placing extra restrictions on XDR data structures (beyond those of the XDR specification).  <a href="namespacexdr.html#a8e7c4c84c79a69d0bad433bff349741a">More...</a><br /></td></tr>
<tr class="separator:a8e7c4c84c79a69d0bad433bff349741a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c8a370f4f726fc09e8b491aa9c597d"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename T &gt; </td></tr>
<tr class="memitem:a83c8a370f4f726fc09e8b491aa9c597d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a83c8a370f4f726fc09e8b491aa9c597d">xdr::archive</a> (Archive &amp;ar, T &amp;&amp;t, const char *name=nullptr)</td></tr>
<tr class="memdesc:a83c8a370f4f726fc09e8b491aa9c597d"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, this function simply applies <code>ar</code> (which must be a function object) to <code>t</code>.  <a href="namespacexdr.html#a83c8a370f4f726fc09e8b491aa9c597d">More...</a><br /></td></tr>
<tr class="separator:a83c8a370f4f726fc09e8b491aa9c597d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d7d468ca38567936bd06d4297541fb"><td class="memTemplParams" colspan="2"><a class="anchor" id="af8d7d468ca38567936bd06d4297541fb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8d7d468ca38567936bd06d4297541fb"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#af8d7d468ca38567936bd06d4297541fb">xdr::xdr_size</a> (const T &amp;t)</td></tr>
<tr class="memdesc:af8d7d468ca38567936bd06d4297541fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the marshaled size of an XDR data type. <br /></td></tr>
<tr class="separator:af8d7d468ca38567936bd06d4297541fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c46504e7ed6a829128f06a8d2ec591"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a74c46504e7ed6a829128f06a8d2ec591"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a74c46504e7ed6a829128f06a8d2ec591">xdr::xdr_reinterpret</a> (From f)</td></tr>
<tr class="memdesc:a74c46504e7ed6a829128f06a8d2ec591"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reinterpret-cast like function that works between types such as floating-point and integers of the same size.  <a href="namespacexdr.html#a74c46504e7ed6a829128f06a8d2ec591">More...</a><br /></td></tr>
<tr class="separator:a74c46504e7ed6a829128f06a8d2ec591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d8c028a76a0f1e55bf501fc3c1ec65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2d8c028a76a0f1e55bf501fc3c1ec65"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; xdr_traits&lt; T &gt;::is_struct &amp;&amp;xdr_traits&lt; T &gt;::xdr_defined, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#aa2d8c028a76a0f1e55bf501fc3c1ec65">xdr::operator==</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:aa2d8c028a76a0f1e55bf501fc3c1ec65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality for XDR structures.  <a href="namespacexdr.html#aa2d8c028a76a0f1e55bf501fc3c1ec65">More...</a><br /></td></tr>
<tr class="separator:aa2d8c028a76a0f1e55bf501fc3c1ec65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295aa6d992235dcacf9851fe3df2f1c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a295aa6d992235dcacf9851fe3df2f1c4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a295aa6d992235dcacf9851fe3df2f1c4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; xdr_traits&lt; T &gt;::is_struct &amp;&amp;xdr_traits&lt; T &gt;::xdr_defined, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xdr::operator!=</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a295aa6d992235dcacf9851fe3df2f1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c2146d23782d298ca4c29ed4a73fba"><td class="memTemplParams" colspan="2"><a class="anchor" id="a41c2146d23782d298ca4c29ed4a73fba"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a41c2146d23782d298ca4c29ed4a73fba"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; xdr_traits&lt; T &gt;::is_struct &amp;&amp;xdr_traits&lt; T &gt;::xdr_defined, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a41c2146d23782d298ca4c29ed4a73fba">xdr::operator&lt;</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a41c2146d23782d298ca4c29ed4a73fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordering of XDR structures. See note at <code><a class="el" href="namespacexdr.html#aa2d8c028a76a0f1e55bf501fc3c1ec65" title="Equality for XDR structures. ">xdr::operator==</a></code>. <br /></td></tr>
<tr class="separator:a41c2146d23782d298ca4c29ed4a73fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d4168bf3ea7ae1fd45bb1b0cf00c64"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56d4168bf3ea7ae1fd45bb1b0cf00c64"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56d4168bf3ea7ae1fd45bb1b0cf00c64"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; xdr_traits&lt; T &gt;::is_struct &amp;&amp;xdr_traits&lt; T &gt;::xdr_defined, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xdr::operator&gt;</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a56d4168bf3ea7ae1fd45bb1b0cf00c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59902ec960fe04e2ae7bda5862ff23ef"><td class="memTemplParams" colspan="2"><a class="anchor" id="a59902ec960fe04e2ae7bda5862ff23ef"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59902ec960fe04e2ae7bda5862ff23ef"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; xdr_traits&lt; T &gt;::is_struct &amp;&amp;xdr_traits&lt; T &gt;::xdr_defined, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xdr::operator&lt;=</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a59902ec960fe04e2ae7bda5862ff23ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4f3ca2ca0c2a74409fc45e67e8823c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2b4f3ca2ca0c2a74409fc45e67e8823c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b4f3ca2ca0c2a74409fc45e67e8823c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; xdr_traits&lt; T &gt;::is_struct &amp;&amp;xdr_traits&lt; T &gt;::xdr_defined, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xdr::operator&gt;=</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a2b4f3ca2ca0c2a74409fc45e67e8823c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8ca76bb3329e159c771984714a890a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c8ca76bb3329e159c771984714a890a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; xdr_traits&lt; T &gt;::is_union, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a9c8ca76bb3329e159c771984714a890a">xdr::operator==</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a9c8ca76bb3329e159c771984714a890a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality of XDR unions.  <a href="namespacexdr.html#a9c8ca76bb3329e159c771984714a890a">More...</a><br /></td></tr>
<tr class="separator:a9c8ca76bb3329e159c771984714a890a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1625a660b09dc7875a814c8ac98493"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1c1625a660b09dc7875a814c8ac98493"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1c1625a660b09dc7875a814c8ac98493"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; xdr_traits&lt; T &gt;::is_union, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a1c1625a660b09dc7875a814c8ac98493">xdr::operator&lt;</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a1c1625a660b09dc7875a814c8ac98493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordering of XDR unions. See note at <code><a class="el" href="namespacexdr.html#aa2d8c028a76a0f1e55bf501fc3c1ec65" title="Equality for XDR structures. ">xdr::operator==</a></code>. <br /></td></tr>
<tr class="separator:a1c1625a660b09dc7875a814c8ac98493"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a83e71e2866065709507c9987df76cdf1"><td class="memItemLeft" align="right" valign="top">Constexpr const field_constructor_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a83e71e2866065709507c9987df76cdf1">xdr::field_constructor</a> {}</td></tr>
<tr class="memdesc:a83e71e2866065709507c9987df76cdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passed to the auto-generated _xdr_with_mem_ptr static method to construct the active union field (or at least the union field corresponding to the second argument to _xdr_with_mem_ptr, which should be the active union field).  <a href="namespacexdr.html#a83e71e2866065709507c9987df76cdf1">More...</a><br /></td></tr>
<tr class="separator:a83e71e2866065709507c9987df76cdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5269831a7acba49000c6b3c6410481"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a5269831a7acba49000c6b3c6410481"></a>
Constexpr const field_destructor_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a8a5269831a7acba49000c6b3c6410481">xdr::field_destructor</a> {}</td></tr>
<tr class="memdesc:a8a5269831a7acba49000c6b3c6410481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passed to _xdr_with_mem_ptr to destroy the active union field. <br /></td></tr>
<tr class="separator:a8a5269831a7acba49000c6b3c6410481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c83bc2f32f255bcdf81fe95a6cf7726"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c83bc2f32f255bcdf81fe95a6cf7726"></a>
Constexpr const field_assigner_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a9c83bc2f32f255bcdf81fe95a6cf7726">xdr::field_assigner</a> {}</td></tr>
<tr class="memdesc:a9c83bc2f32f255bcdf81fe95a6cf7726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passed to _xdr_with_mem_ptr to assign to the active union field. <br /></td></tr>
<tr class="separator:a9c83bc2f32f255bcdf81fe95a6cf7726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187692134e50a318d5159f3a014e92d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a187692134e50a318d5159f3a014e92d7"></a>
Constexpr const field_archiver_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a187692134e50a318d5159f3a014e92d7">xdr::field_archiver</a> {}</td></tr>
<tr class="memdesc:a187692134e50a318d5159f3a014e92d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passed to _xdr_with_mem_ptr to archive the active union field. <br /></td></tr>
<tr class="separator:a187692134e50a318d5159f3a014e92d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ac39dce2cf36ae6fdaa09f47e7a6a0"><td class="memItemLeft" align="right" valign="top">Constexpr const field_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a33ac39dce2cf36ae6fdaa09f47e7a6a0">xdr::field_size</a> {}</td></tr>
<tr class="memdesc:a33ac39dce2cf36ae6fdaa09f47e7a6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passed to _xdr_with_mem_ptr to compute the size of the active union field.  <a href="namespacexdr.html#a33ac39dce2cf36ae6fdaa09f47e7a6a0">More...</a><br /></td></tr>
<tr class="separator:a33ac39dce2cf36ae6fdaa09f47e7a6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Type definitions for xdrc compiler output. </p>

<p>Definition in file <a class="el" href="types_8h_source.html">types.h</a>.</p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 25 2016 03:05:28 for xdrpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
